from pathlib import Path

def create_template(path: str, content: str):
    file_path = Path(path)
    file_path.parent.mkdir(parents=True, exist_ok=True)
    file_path.write_text(content.strip(), encoding='utf-8')
    print(f"✅ {path}")

# .dockerignore.j2
DOCKERIGNORE = '''
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
*.egg-info/
dist/
build/

# Environment
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# Git
.git/
.gitignore

# Testing
.pytest_cache/
.coverage
htmlcov/

# Documentation
docs/
*.md
!README.md

# Logs
*.log
logs/

# Database
*.db
*.sqlite
*.sqlite3

# OS
.DS_Store
Thumbs.db
'''

# app.py.j2
APP_PY = '''"""
Application entry point
Generated by RDT v2.0
"""
from src import create_app

app = create_app()

if __name__ == '__main__':
    app.run(
        host='0.0.0.0',
        port={{ port }},
        debug={{ 'True' if is_development else 'False' }}
    )
'''

# docker-compose.yml.j2
DOCKER_COMPOSE = '''version: '3.8'

services:
  app:
    build: .
    container_name: {{ name }}_app
    ports:
      - "{{ port }}:{{ port }}"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      {% if auth_enabled -%}
      - JWT_SECRET_KEY=${JWT_SECRET_KEY}
      {% endif -%}
      - ENVIRONMENT=${ENVIRONMENT:-development}
    {% if database != 'SQLite' -%}
    depends_on:
      db:
        condition: service_healthy
    {% endif -%}
    volumes:
      - .:/app
    networks:
      - app-network
    restart: unless-stopped

  {% if database == 'PostgreSQL' -%}
  db:
    image: postgres:15-alpine
    container_name: {{ name }}_db
    environment:
      POSTGRES_USER: ${PGUSER:-postgres}
      POSTGRES_PASSWORD: ${PGPASSWORD:-postgres}
      POSTGRES_DB: {{ name }}_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${PGUSER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
  {% elif database == 'MySQL' -%}
  db:
    image: mysql:8.0
    container_name: {{ name }}_db
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-rootpassword}
      MYSQL_DATABASE: {{ name }}_db
      MYSQL_USER: ${MYSQL_USER:-appuser}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-apppassword}
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
  {% endif -%}

  redis:
    image: redis:7-alpine
    container_name: {{ name }}_redis
    ports:
      - "6379:6379"
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    restart: unless-stopped

networks:
  app-network:
    driver: bridge

{% if database != 'SQLite' -%}
volumes:
  {% if database == 'PostgreSQL' -%}
  postgres_data:
  {% elif database == 'MySQL' -%}
  mysql_data:
  {% endif -%}
{% endif -%}
'''

# env.example.j2
ENV_EXAMPLE = '''# Database Configuration
{% if database == 'PostgreSQL' -%}
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/{{ name }}_db
PGUSER=postgres
PGPASSWORD=postgres
{% elif database == 'MySQL' -%}
DATABASE_URL=mysql://root:rootpassword@localhost:3306/{{ name }}_db
MYSQL_ROOT_PASSWORD=rootpassword
MYSQL_USER=appuser
MYSQL_PASSWORD=apppassword
{% elif database == 'SQLite' -%}
DATABASE_URL=sqlite:///{{ name }}.db
{% endif -%}

{% if auth_enabled -%}
# JWT Configuration
JWT_SECRET_KEY=change-this-to-a-secure-random-string-min-32-characters
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRES=3600

{% endif -%}
# Application Configuration
ENVIRONMENT=development
DEBUG=True
HOST=0.0.0.0
PORT={{ port }}

# CORS Configuration
CORS_ORIGINS=["http://localhost:3000","http://localhost:{{ port }}"]
'''

# .gitignore.j2
GITIGNORE = '''# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
venv/
env/
ENV/
.venv

# Environment variables
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
.DS_Store

# Testing
.pytest_cache/
.coverage
.coverage.*
htmlcov/
*.cover
.hypothesis/

# Logs
*.log
logs/

# Database
*.db
*.sqlite
*.sqlite3

# Flask
instance/
.webassets-cache

# Django
*.pot
local_settings.py
db.sqlite3-journal

# Migrations (uncomment if needed)
# migrations/

# OS
.DS_Store
Thumbs.db
'''

# LICENSE.j2
LICENSE = '''MIT License

Copyright (c) {{ year }} {{ name }}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'''

# pyproject.toml.j2
PYPROJECT_TOML = '''[tool.poetry]
name = "{{ name }}"
version = "0.1.0"
description = "{{ name }} API"
authors = ["Your Name <your.email@example.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^{{ python_version }}"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-cov = "^4.1.0"
black = "^23.12.0"
ruff = "^0.1.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 100
target-version = ["py{{ python_version | replace('.', '') }}"]

[tool.ruff]
line-length = 100
select = ["E", "F", "W", "I"]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
addopts = "-v --cov=src --cov-report=term-missing"
'''

# pytest.ini.j2
PYTEST_INI = '''[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts =
    -v
    --strict-markers
    --tb=short
    --cov=src
    --cov-report=html
    --cov-report=term-missing
    {% if is_async -%}
    --asyncio-mode=auto
    {% endif -%}

markers =
    slow: marks tests as slow
    integration: marks tests as integration tests
    unit: marks tests as unit tests
'''

# security.py.j2
SECURITY_PY = '''"""
Security utilities and middleware
Generated by RDT v2.0
"""
{% if framework == 'Flask-Restx' -%}
from functools import wraps
from flask import request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
import jwt
from datetime import datetime, timedelta
{% elif framework == 'FastAPI' -%}
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
{% endif -%}
import secrets
import re


class PasswordValidator:
    """Validate and hash passwords"""

    MIN_LENGTH = 8

    @staticmethod
    def validate(password: str) -> tuple[bool, list[str]]:
        """Validate password strength"""
        errors = []

        if len(password) < PasswordValidator.MIN_LENGTH:
            errors.append(f"Password must be at least {PasswordValidator.MIN_LENGTH} characters")

        if not re.search(r"[A-Z]", password):
            errors.append("Password must contain at least one uppercase letter")

        if not re.search(r"[a-z]", password):
            errors.append("Password must contain at least one lowercase letter")

        if not re.search(r"\d", password):
            errors.append("Password must contain at least one digit")

        if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
            errors.append("Password must contain at least one special character")

        return len(errors) == 0, errors

    {% if framework == 'Flask-Restx' -%}
    @staticmethod
    def hash_password(password: str) -> str:
        """Hash password using werkzeug"""
        return generate_password_hash(password, method='pbkdf2:sha256')

    @staticmethod
    def verify_password(password: str, password_hash: str) -> bool:
        """Verify password against hash"""
        return check_password_hash(password_hash, password)
    {% elif framework == 'FastAPI' -%}
    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

    @staticmethod
    def hash_password(password: str) -> str:
        """Hash password"""
        return PasswordValidator.pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """Verify password"""
        return PasswordValidator.pwd_context.verify(plain_password, hashed_password)
    {% endif -%}


class InputSanitizer:
    """Sanitize user input"""

    @staticmethod
    def sanitize_email(email: str) -> str:
        """Validate and sanitize email"""
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

        if not re.match(email_pattern, email):
            raise ValueError("Invalid email format")

        return email.lower().strip()

    @staticmethod
    def sanitize_username(username: str) -> str:
        """Validate and sanitize username"""
        username = username.strip()

        if len(username) < 3:
            raise ValueError("Username must be at least 3 characters")

        if not re.match(r'^[a-zA-Z0-9_-]+$', username):
            raise ValueError("Username can only contain letters, numbers, hyphens and underscores")

        return username


{% if framework == 'FastAPI' -%}
security = HTTPBearer()


def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """Get current user from JWT token"""
    token = credentials.credentials

    try:
        # Decode JWT
        payload = jwt.decode(token, "SECRET_KEY", algorithms=["HS256"])
        return payload
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
{% endif -%}
'''

# Crear todos los templates
templates = {
    'templates/common/.dockerignore.j2': DOCKERIGNORE,
    'templates/common/app.py.j2': APP_PY,
    'templates/common/docker-compose.yml.j2': DOCKER_COMPOSE,
    'templates/common/env.example.j2': ENV_EXAMPLE,
    'templates/common/gitignore.j2': GITIGNORE,
    'templates/common/LICENSE.j2': LICENSE,
    'templates/common/pyproject.toml.j2': PYPROJECT_TOML,
    'templates/common/pytest.ini.j2': PYTEST_INI,
    'templates/common/security.py.j2': SECURITY_PY,
}

print("Creating common templates...\n")
for path, content in templates.items():
    create_template(path, content)

print(f"\n✅ Created {len(templates)} common templates!")
print("\nTemplates created:")
for path in templates.keys():
    print(f"  • {path}")

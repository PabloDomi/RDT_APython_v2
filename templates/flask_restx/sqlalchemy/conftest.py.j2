"""
Pytest configuration and fixtures
Generated by RDT v2.0
"""
import pytest
import os
from dotenv import load_dotenv

# Load test environment first (before any other imports)
test_env_file = os.path.join(os.path.dirname(__file__), '..', '.env.test')
if os.path.exists(test_env_file):
    load_dotenv(test_env_file, override=True)
    print(f"✅ Loaded test config from {test_env_file}")
else:
    # Fallback to manual configuration
    print("⚠️ No .env.test found, using manual config")
    os.environ['TEST_DB_TYPE'] = 'sqlite'
    os.environ['DATABASE_URL'] = 'sqlite:///:memory:'

# Test database configuration - can be overridden with environment variables
TEST_DB_TYPE = os.getenv('TEST_DB_TYPE', 'sqlite')
TEST_DB_HOST = os.getenv('TEST_DB_HOST', 'localhost')
TEST_DB_PORT = os.getenv('TEST_DB_PORT', '5432')
TEST_DB_USER = os.getenv('TEST_DB_USER', 'postgres')
TEST_DB_PASSWORD = os.getenv('TEST_DB_PASSWORD', '1234')
TEST_DB_NAME = os.getenv('TEST_DB_NAME', 'test_rdt_example')

# Configure database URL based on type
if TEST_DB_TYPE.lower() == 'postgresql':
    test_db_url = f'postgresql://{TEST_DB_USER}:{TEST_DB_PASSWORD}@{TEST_DB_HOST}:{TEST_DB_PORT}/{TEST_DB_NAME}'
elif TEST_DB_TYPE.lower() == 'mysql':
    mysql_port = os.getenv('TEST_DB_PORT', '3306')
    test_db_url = f'mysql://{TEST_DB_USER}:{TEST_DB_PASSWORD}@{TEST_DB_HOST}:{mysql_port}/{TEST_DB_NAME}'
else:
    # Default to SQLite in memory (fastest for tests)
    test_db_url = 'sqlite:///:memory:'

# Force test environment configuration before importing anything
os.environ['DATABASE_URL'] = test_db_url
os.environ['SQLALCHEMY_DATABASE_URI'] = test_db_url
os.environ['TESTING'] = 'True'

from src import create_app
from src.extensions import db as _db
from src.models.models import User{% if auth_enabled %}, Item{% endif %}


@pytest.fixture(scope='session')
def app():
    """Create application for testing"""
    app = create_app()
    app.config.update({
        'TESTING': True,
        'SQLALCHEMY_DATABASE_URI': 'sqlite:///:memory:',
        'WTF_CSRF_ENABLED': False,
        'JWT_SECRET_KEY': 'test-secret-key-for-testing',
        'JWT_ACCESS_TOKEN_EXPIRES': False,
    })
    
    with app.app_context():
        _db.create_all()
        yield app
        try:
            _db.drop_all()
            _db.session.remove()
        except Exception:
            # If cleanup fails, just close the session
            _db.session.close()


@pytest.fixture(scope='function')
def db(app):
    """Create clean database for each test"""
    with app.app_context():
        yield _db
        # Clean up after each test - handle rollbacks from failed operations
        try:
            _db.session.rollback()  # Rollback any pending transaction
        except:
            pass
        
        try:
            # For PostgreSQL/MySQL, use TRUNCATE for better performance
            if TEST_DB_TYPE.lower() in ['postgresql', 'mysql']:
                _db.session.execute('TRUNCATE TABLE users CASCADE' if TEST_DB_TYPE.lower() == 'postgresql' else 'TRUNCATE TABLE users')
{% if auth_enabled %}
                _db.session.execute('TRUNCATE TABLE items CASCADE' if TEST_DB_TYPE.lower() == 'postgresql' else 'TRUNCATE TABLE items')
{% endif %}
            else:
                # SQLite uses DELETE
                _db.session.query(User).delete()
{% if auth_enabled %}
                _db.session.query(Item).delete()
{% endif %}
            _db.session.commit()
        except Exception:
            _db.session.rollback()  # If cleanup fails, rollback


@pytest.fixture(scope='function')
def client(app):
    """Create test client"""
    return app.test_client()

{% if auth_enabled %}

@pytest.fixture(scope='function')
def test_user(db):
    """Create test user"""
    user = User(username='testuser', email='test@example.com')
    user.set_password('TestPassword123!')
    db.session.add(user)
    db.session.commit()
    return user


@pytest.fixture(scope='function')
def auth_token(client, test_user):
    """Get authentication token"""
    response = client.post('/auth/login', json={
        'username': 'testuser',
        'password': 'TestPassword123!'
    })
    
    assert response.status_code == 200, f"Login failed: {response.json}"
    return response.json['access_token']


@pytest.fixture(scope='function')
def auth_headers(auth_token):
    """Get authorization headers"""
    return {
        'Authorization': f'Bearer {auth_token}',
        'Content-Type': 'application/json'
    }
{% endif %}